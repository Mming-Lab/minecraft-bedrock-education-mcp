#!/usr/bin/env node

/**
 * ÂåÖÊã¨ÁöÑ„É¨„Çπ„Éù„É≥„Çπ„ÉÜ„Çπ„Éà„Çπ„ÇØ„É™„Éó„Éà
 * 
 * ÈáçË¶Å„Å™Êàª„ÇäÂÄ§„ÇíÊåÅ„Å§ÂÖ®„Å¶„ÅÆMinecraft„Ç≥„Éû„É≥„Éâ„Çí„ÉÜ„Çπ„Éà„Åó„ÄÅ
 * ÁµêÊûú„ÇíËá™ÂãïËß£Êûê„Åó„Å¶„É¨„Éù„Éº„Éà„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
 */

const WebSocket = require('ws');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs');
const path = require('path');

// „ÉÜ„Çπ„ÉàË®≠ÂÆö
const SERVER_URL = 'ws://localhost:8001/ws';
const TEST_TIMEOUT = 15000; // 15Áßí
const REPORT_FILE = 'tests/response-analysis-report.json';

console.log('=== ÂåÖÊã¨ÁöÑ„Ç≥„Éû„É≥„Éâ„É¨„Çπ„Éù„É≥„Çπ„ÉÜ„Çπ„Éà ===\n');

/**
 * „ÉÜ„Çπ„ÉàÂØæË±°„ÅÆ„Ç≥„Éû„É≥„ÉâÂÆöÁæ©
 */
const CRITICAL_COMMANDS = [
    {
        name: 'QueryTarget',
        command: 'querytarget @s',
        expectedFields: ['position', 'yRot', 'dimension'],
        category: 'player_info',
        description: '„Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ„ÉªÁä∂ÊÖãÂèñÂæó'
    },
    {
        name: 'TestFor',
        command: 'testfor @s',
        expectedFields: ['statusCode'],
        category: 'existence_check',
        description: '„Éó„É¨„Ç§„É§„ÉºÂ≠òÂú®Á¢∫Ë™ç'
    },
    {
        name: 'GameMode Query',
        command: 'gamemode query @s',
        expectedFields: ['statusCode', 'statusMessage'],
        category: 'player_info',
        description: '„Ç≤„Éº„É†„É¢„Éº„ÉâÂèñÂæó'
    },
    {
        name: 'Time Query',
        command: 'time query daytime',
        expectedFields: ['statusCode', 'statusMessage'],
        category: 'world_info',
        description: 'ÊôÇÈñìÊÉÖÂ†±ÂèñÂæó'
    },
    {
        name: 'Block Test',
        command: 'testforblock ~ ~ ~ air',
        expectedFields: ['statusCode'],
        category: 'block_check',
        description: '„Éñ„É≠„ÉÉ„ÇØÂ≠òÂú®Á¢∫Ë™ç'
    },
    {
        name: 'Player Count',
        command: 'list',
        expectedFields: ['statusCode', 'statusMessage'],
        category: 'server_info',
        description: '„Éó„É¨„Ç§„É§„Éº‰∏ÄË¶ß'
    },
    {
        name: 'Scoreboard Query',
        command: 'scoreboard players list @s',
        expectedFields: ['statusCode'],
        category: 'score_info',
        description: '„Çπ„Ç≥„Ç¢ÊÉÖÂ†±ÂèñÂæó'
    }
];

/**
 * „ÉÜ„Çπ„ÉàÁµêÊûúÊ†ºÁ¥ç
 */
let testResults = {
    timestamp: new Date().toISOString(),
    summary: {
        total: 0,
        passed: 0,
        failed: 0,
        warnings: 0
    },
    commands: [],
    analysis: {
        responsePatterns: {},
        problematicCommands: [],
        recommendations: []
    }
};

/**
 * Minecraft„É°„ÉÉ„Çª„Éº„Ç∏‰ΩúÊàê
 */
function createMinecraftMessage(purpose, body) {
    return {
        header: {
            version: 1,
            requestId: uuidv4(),
            messagePurpose: purpose
        },
        body: body
    };
}

/**
 * „É¨„Çπ„Éù„É≥„ÇπÊßãÈÄ†„ÅÆË©≥Á¥∞Ëß£Êûê
 */
function analyzeResponseStructure(response, commandDef) {
    const analysis = {
        hasHeader: !!response.header,
        hasBody: !!response.body,
        statusCode: response.body?.statusCode,
        hasExpectedFields: false,
        fieldAnalysis: {},
        dataStructure: {},
        issues: []
    };

    // Âü∫Êú¨ÊßãÈÄ†„ÉÅ„Çß„ÉÉ„ÇØ
    if (!analysis.hasHeader) {
        analysis.issues.push('Missing header');
    }
    if (!analysis.hasBody) {
        analysis.issues.push('Missing body');
    }

    // „Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„ÉâËß£Êûê
    if (typeof analysis.statusCode === 'number') {
        analysis.statusCodeValid = true;
        if (analysis.statusCode === 0) {
            analysis.statusCodeMeaning = 'Success';
        } else if (analysis.statusCode > 0) {
            analysis.statusCodeMeaning = 'Error/Warning';
        }
    } else {
        analysis.issues.push('Invalid or missing statusCode');
    }

    // ÁâπÂà•„Å™„Éï„Ç£„Éº„É´„ÉâËß£ÊûêÔºàQueryTarget„Å™„Å©Ôºâ
    if (commandDef.name === 'QueryTarget') {
        try {
            const details = response.body?.details || response.body?.statusMessage;
            if (details) {
                const playerData = JSON.parse(details);
                if (Array.isArray(playerData) && playerData.length > 0) {
                    const player = playerData[0];
                    analysis.dataStructure.position = player.position;
                    analysis.dataStructure.rotation = player.yRot;
                    analysis.dataStructure.dimension = player.dimension;
                    analysis.hasExpectedFields = true;
                    
                    // Â∫ßÊ®ô„ÅÆÂ¶•ÂΩìÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
                    if (player.position) {
                        const { x, y, z } = player.position;
                        if (typeof x !== 'number' || typeof y !== 'number' || typeof z !== 'number') {
                            analysis.issues.push('Invalid coordinate data types');
                        }
                        if (y < -64 || y > 320) {
                            analysis.issues.push('Y coordinate out of valid range');
                        }
                    }
                }
            }
        } catch (e) {
            analysis.issues.push(`QueryTarget JSON parse error: ${e.message}`);
        }
    }

    // ÊúüÂæÖ„Åï„Çå„Çã„Éï„Ç£„Éº„É´„Éâ„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    for (const field of commandDef.expectedFields) {
        if (field === 'position' || field === 'yRot' || field === 'dimension') {
            // QueryTargetÁâπÂà•Âá¶ÁêÜÊ∏à„Åø
            continue;
        }
        
        const hasField = response.body && (field in response.body);
        analysis.fieldAnalysis[field] = {
            present: hasField,
            value: hasField ? response.body[field] : null,
            type: hasField ? typeof response.body[field] : null
        };
    }

    return analysis;
}

/**
 * Âçò‰∏Ä„Ç≥„Éû„É≥„Éâ„ÉÜ„Çπ„ÉàÂÆüË°å
 */
async function testCommand(ws, commandDef) {
    console.log(`\nüìã „ÉÜ„Çπ„Éà: ${commandDef.name} (${commandDef.description})`);
    
    const commandRequest = createMinecraftMessage('commandRequest', {
        origin: { type: 'player' },
        commandLine: commandDef.command,
        version: 1
    });

    try {
        const response = await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error(`„Çø„Ç§„É†„Ç¢„Ç¶„Éà: ${commandDef.name}`));
            }, 8000);

            const messageHandler = (data) => {
                try {
                    const parsed = JSON.parse(data.toString());
                    if (parsed.header?.messagePurpose === 'commandResponse' &&
                        parsed.header.requestId === commandRequest.header.requestId) {
                        clearTimeout(timeout);
                        ws.removeListener('message', messageHandler);
                        resolve(parsed);
                    }
                } catch (e) {
                    // JSONËß£Êûê„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
                }
            };

            ws.on('message', messageHandler);
            ws.send(JSON.stringify(commandRequest));
        });

        // „É¨„Çπ„Éù„É≥„ÇπËß£Êûê
        const analysis = analyzeResponseStructure(response, commandDef);
        
        const testResult = {
            command: commandDef.name,
            commandLine: commandDef.command,
            category: commandDef.category,
            success: analysis.issues.length === 0,
            response: response,
            analysis: analysis,
            timestamp: new Date().toISOString()
        };

        // ÁµêÊûúË°®Á§∫
        if (testResult.success) {
            console.log(`  ‚úÖ ÊàêÂäü: ${commandDef.description}`);
            testResults.summary.passed++;
        } else {
            console.log(`  ‚ùå ÂïèÈ°åÁô∫Ë¶ã: ${analysis.issues.join(', ')}`);
            testResults.summary.failed++;
            testResults.analysis.problematicCommands.push({
                command: commandDef.name,
                issues: analysis.issues
            });
        }

        // Ë©≥Á¥∞ÊÉÖÂ†±Ë°®Á§∫
        if (analysis.statusCode !== undefined) {
            console.log(`    „Çπ„ÉÜ„Éº„Çø„Çπ: ${analysis.statusCode} (${analysis.statusCodeMeaning || 'Unknown'})`);
        }
        
        if (commandDef.name === 'QueryTarget' && analysis.dataStructure.position) {
            const pos = analysis.dataStructure.position;
            console.log(`    ‰ΩçÁΩÆ: X=${pos.x}, Y=${pos.y}, Z=${pos.z}`);
        }

        testResults.commands.push(testResult);
        testResults.summary.total++;

        return testResult;

    } catch (error) {
        console.log(`  ‚ùå „Ç®„É©„Éº: ${error.message}`);
        
        const failedResult = {
            command: commandDef.name,
            commandLine: commandDef.command,
            category: commandDef.category,
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        };

        testResults.commands.push(failedResult);
        testResults.summary.total++;
        testResults.summary.failed++;
        
        return failedResult;
    }
}

/**
 * ÁµêÊûúÂàÜÊûê„Å®„É¨„Éù„Éº„ÉàÁîüÊàê
 */
function generateAnalysisReport() {
    console.log('\n\n=== üìä „ÉÜ„Çπ„ÉàÁµêÊûúÂàÜÊûê ===');
    
    // „Ç´„ÉÜ„Ç¥„É™Âà•ÈõÜË®à
    const categoryStats = {};
    testResults.commands.forEach(result => {
        if (!categoryStats[result.category]) {
            categoryStats[result.category] = { total: 0, passed: 0, failed: 0 };
        }
        categoryStats[result.category].total++;
        if (result.success) {
            categoryStats[result.category].passed++;
        } else {
            categoryStats[result.category].failed++;
        }
    });

    console.log('\nüìà „Ç´„ÉÜ„Ç¥„É™Âà•ÁµêÊûú:');
    Object.entries(categoryStats).forEach(([category, stats]) => {
        const successRate = ((stats.passed / stats.total) * 100).toFixed(1);
        console.log(`  ${category}: ${stats.passed}/${stats.total} (${successRate}%)`);
    });

    // Êé®Â•®‰∫ãÈ†ÖÁîüÊàê
    const recommendations = [];
    
    if (testResults.summary.failed > 0) {
        recommendations.push('Â§±Êïó„Åó„Åü„Ç≥„Éû„É≥„Éâ„ÅÆË©≥Á¥∞„ÇíÁ¢∫Ë™ç„Åó„ÄÅWebSocketÂÆüË£Ö„ÇíË¶ãÁõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
    }
    
    const queryTargetResult = testResults.commands.find(cmd => cmd.command === 'QueryTarget');
    if (queryTargetResult && !queryTargetResult.success) {
        recommendations.push('QueryTarget„Ç≥„Éû„É≥„Éâ„ÅØ‰ΩçÁΩÆÂèñÂæó„Å´ÈáçË¶Å„Åß„Åô„ÄÇÂÑ™ÂÖàÁöÑ„Å´‰øÆÊ≠£„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
    }

    if (categoryStats.player_info && categoryStats.player_info.failed > 0) {
        recommendations.push('„Éó„É¨„Ç§„É§„ÉºÊÉÖÂ†±ÂèñÂæó„Ç≥„Éû„É≥„Éâ„Å´ÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇMCPÊ©üËÉΩ„Å´ÂΩ±Èüø„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô');
    }

    testResults.analysis.recommendations = recommendations;

    // „Éï„Ç°„Ç§„É´Âá∫Âäõ
    const reportPath = path.resolve(REPORT_FILE);
    fs.writeFileSync(reportPath, JSON.stringify(testResults, null, 2));
    
    console.log(`\nüíæ Ë©≥Á¥∞„É¨„Éù„Éº„Éà: ${reportPath}`);
    
    return testResults;
}

/**
 * „É°„Ç§„É≥„ÉÜ„Çπ„ÉàÂÆüË°å
 */
async function runComprehensiveTests() {
    try {
        console.log('üîå WebSocket„Çµ„Éº„Éê„ÉºÊé•Á∂ö‰∏≠...');
        
        const ws = new WebSocket(SERVER_URL);
        
        await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Êé•Á∂ö„Çø„Ç§„É†„Ç¢„Ç¶„Éà'));
            }, 5000);
            
            ws.on('open', () => {
                clearTimeout(timeout);
                console.log('‚úÖ Êé•Á∂öÊàêÂäü\n');
                resolve();
            });
            
            ws.on('error', reject);
        });

        // ÊöóÂè∑Âåñ„Éè„É≥„Éâ„Ç∑„Çß„Ç§„ÇØ
        const encryptRequest = createMinecraftMessage('ws:encrypt', {});
        ws.send(JSON.stringify(encryptRequest));
        
        // Áü≠ÊôÇÈñìÂæÖÊ©ü
        await new Promise(resolve => setTimeout(resolve, 1000));

        console.log('üß™ „Ç≥„Éû„É≥„Éâ„ÉÜ„Çπ„ÉàÈñãÂßã...');
        
        // ÂÖ®„Ç≥„Éû„É≥„Éâ„ÉÜ„Çπ„ÉàÂÆüË°å
        for (const commandDef of CRITICAL_COMMANDS) {
            await testCommand(ws, commandDef);
            // „Ç≥„Éû„É≥„ÉâÈñì„ÅÆÈñìÈöî
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        ws.close();

        // ÁµêÊûúÂàÜÊûê
        const analysis = generateAnalysisReport();
        
        // ÊúÄÁµÇÁµêÊûúË°®Á§∫
        console.log('\n=== üéØ ÊúÄÁµÇÁµêÊûú ===');
        console.log(`Á∑èÂêàÊàêÂäüÁéá: ${((analysis.summary.passed / analysis.summary.total) * 100).toFixed(1)}%`);
        console.log(`ÊàêÂäü: ${analysis.summary.passed}, Â§±Êïó: ${analysis.summary.failed}`);
        
        if (analysis.analysis.recommendations.length > 0) {
            console.log('\nüí° Êé®Â•®‰∫ãÈ†Ö:');
            analysis.analysis.recommendations.forEach((rec, i) => {
                console.log(`  ${i + 1}. ${rec}`);
            });
        }

        process.exit(analysis.summary.failed === 0 ? 0 : 1);

    } catch (error) {
        console.error('‚ùå „ÉÜ„Çπ„ÉàÂÆüË°å„Ç®„É©„Éº:', error.message);
        process.exit(1);
    }
}

// „É°„Ç§„É≥ÂÆüË°å
runComprehensiveTests();